<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- ... (head content as before) ... -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ジャンプキング風ゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... (styles as before) ... */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 画面スクロールを禁止 */
            background-color: #333;
            font-family: 'Inter', sans-serif;
        }
        #game-canvas {
            display: block;
            /* 背景色はJSで制御するため削除 */
            width: 100%;
            height: 100%;
            object-fit: contain; /* アスペクト比を維持 */
            cursor: pointer; /* ★ タップ可能を示すカーソル */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 10;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-btn {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%; /* 円形ボタン */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-btn:active {
            background-color: rgba(255, 255, 255, 0.7);
        }

        /* ★ BGMボタン用のスタイル */
        #mute-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid white;
            cursor: pointer;
            margin-top: 8px;
            font-size: 14px;
        }
        #mute-btn:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="message-box" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg shadow-lg text-center hidden">
            <p id="message-text" class="text-xl font-bold mb-4"></p>
            <button id="message-ok" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                OK
            </button>
        </div>
        <!-- チュートリアル/スコア表示 -->
        <div id="info-display" class="absolute top-4 left-4 text-white text-lg font-bold p-2 bg-black bg-opacity-30 rounded-lg">
            <p>Space / JUMP長押し + 左右キーで方向決定！</p>
            <p>最高到達点: <span id="max-height-display">0</span>m</p>
            <p>現在の高さ: <span id="current-height-display">0</span>m</p>
            <p>プレイ回数: <span id="play-count-display">0</span>回</p>
            <button id="mute-btn">BGM ON/OFF</button>
            <!-- 神モードボタンは削除済み -->
        </div>
    </div>

    <div id="touch-controls">
        <div class="flex space-x-4">
            <button id="btn-left" class="touch-btn">◀</button>
            <button id="btn-right" class="touch-btn">▶</button>
        </div>
        <button id="btn-jump" class="touch-btn w-20 h-20">JUMP</button>
    </div>

    <!-- BGM用Audioタグ (パスは公開用) -->
    <audio id="bgm-audio" loop src="/jumpingmidori/闇のささやき.mp3"></audio>

    <script type="module">
        // --- グローバル変数・定数 ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const infoDisplay = document.getElementById('info-display');
        const maxHeightDisplay = document.getElementById('max-height-display');
        const currentHeightDisplay = document.getElementById('current-height-display');
        const playCountDisplay = document.getElementById('play-count-display');

        // BGM関連
        const bgm = document.getElementById('bgm-audio');
        const muteBtn = document.getElementById('mute-btn');
        let audioStarted = false;

        // 神モード（落下しない）フラグ
        let godMode = false;
        // 神モード切り替え用のタップカウント
        let playerTapCount = 0;
        let lastPlayerTapTime = 0;
        const tapTimeout = 500; // 500ms以内に連続タップ
        let showTapFeedback = false; // ★ タップフィードバック表示用フラグ
        let tapFeedbackTimer = null; // ★ フィードバック表示タイマー

        // ゲーム内単位での仮想解像度
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;

        let player;
        let platforms = [];
        let keys = { ArrowLeft: false, ArrowRight: false, Space: false };

        // 画像読み込み用の変数
        let playerImage;
        let gameStarted = false;

        // プレイ回数カウンター
        let playCount = 0;

        // 物理定数
        const GRAVITY = 0.3;
        const FRICTION = 0.85;
        const AIR_FRICTION = 0.99;
        const JUMP_HORIZONTAL_SPEED_MIN = 0.5;
        const JUMP_HORIZONTAL_SPEED_MAX = 6;
        const MAX_JUMP_CHARGE = 100;
        const JUMP_FORCE_MIN = 1;
        const JUMP_FORCE_MAX = 15;

        let isCharging = false;
        let jumpCharge = 0;
        let cameraY = 0;
        let worldHeight = 5000;
        let maxHeightReached = 0;
        let pixelsPerMeter = 10;

        // メッセージボックス
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOk = document.getElementById('message-ok');

        // --- クラス定義 ---

        // プレイヤー
        class Player {
            constructor(x, y) {
                this.width = 20;
                this.height = 30;
                this.x = x - this.width / 2;
                this.y = y - this.height;
                this.vx = 0;
                this.vy = 0;
                this.onGround = false;
                this.color = '#FF5733';
                this.direction = 'right';
            }

            // プレイヤーの更新
            update() {
                // ... (方向転換、物理演算、壁・足場当たり判定は変更なし) ...
                 // 1. 方向転換 (地上かつ非チャージ中のみ)
                if (this.onGround && !isCharging) {
                    if (keys.ArrowLeft) this.direction = 'left';
                    else if (keys.ArrowRight) this.direction = 'right';
                    this.vx = 0;
                } else if (this.onGround) {
                    this.vx = 0; // チャージ中も停止
                }

                // 2. 物理演算
                this.vy += GRAVITY;
                if (!this.onGround) this.vx *= AIR_FRICTION; // 空中減衰

                // 速度閾値
                if (Math.abs(this.vx) < 0.1) this.vx = 0;
                if (Math.abs(this.vy) < 0.1 && this.onGround && !isCharging) this.vy = 0;

                const prevX = this.x;
                const prevY = this.y;

                // 3. 位置更新
                this.x += this.vx;
                this.y += this.vy;
                this.onGround = false; // リセット

                // 4. 壁当たり判定 (反転)
                if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
                if (this.x + this.width > GAME_WIDTH) { this.x = GAME_WIDTH - this.width; this.vx *= -0.5; }

                // 5. 足場当たり判定
                platforms.forEach(platform => {
                    const isCollidingX = this.x + this.width > platform.x && this.x < platform.x + platform.width;
                    const isCollidingY = this.y + this.height > platform.y && this.y < platform.y + platform.height;
                    const wasCollidingX = prevX + this.width > platform.x && prevX < platform.x + platform.width;

                    if (isCollidingX && isCollidingY) {
                        // 上から着地
                        if (prevY + this.height <= platform.y && this.y + this.height > platform.y && this.vy >= 0) {
                            this.y = platform.y - this.height;
                            this.vy = 0;
                            this.onGround = true;
                        }
                        // 下から衝突
                        else if (prevY >= platform.y + platform.height && this.y < platform.y + platform.height && this.vy < 0) {
                            this.y = platform.y + platform.height;
                            this.vy = 0;
                        }
                    }

                    // 横から衝突 (空中)
                    if (!this.onGround && !isCollidingY && !wasCollidingX) {
                         const wasCollidingY = prevY + this.height > platform.y && prevY < platform.y + platform.height;
                         if (isCollidingX && wasCollidingY) {
                             if (this.vx > 0 && prevX + this.width <= platform.x) { // 右へ
                                 this.x = platform.x - this.width;
                                 this.vx *= -0.5;
                             } else if (this.vx < 0 && prevX >= platform.x + platform.width) { // 左へ
                                 this.x = platform.x + platform.width;
                                 this.vx *= -0.5;
                             }
                         }
                    }
                });


                // 6. 落下判定
                const fallThreshold = cameraY + GAME_HEIGHT + 100;
                // 神モード(godMode)が false の場合のみ落下処理
                if (this.y > fallThreshold && !godMode) {
                    showFallMessage();
                }

                // 7. 高さ更新
                const currentHeightInMeters = Math.max(0, Math.floor((worldHeight - this.y) / pixelsPerMeter));
                if (currentHeightDisplay) currentHeightDisplay.textContent = currentHeightInMeters;

                if (this.y < maxHeightReached) {
                    maxHeightReached = this.y;
                    const heightInMeters = Math.floor((worldHeight - maxHeightReached) / pixelsPerMeter);
                    maxHeightDisplay.textContent = heightInMeters;
                }
            }

            // プレイヤーの描画
            draw(ctx) {
                ctx.save();

                // ★ タップフィードバック (白く光る)
                if (showTapFeedback) {
                     ctx.filter = 'brightness(2)';
                }
                // ★ 神モードの視覚フィードバック (黄色フィルター)
                else if (godMode) {
                    ctx.filter = 'sepia(80%) hue-rotate(-50deg) saturate(500%) brightness(1.1)';
                }

                // ジャンプゲージ
                if (isCharging) {
                    // ... (ゲージ描画は変更なし) ...
                    const chargeRatio = jumpCharge / MAX_JUMP_CHARGE;
                    const barWidth = this.width;
                    const barHeight = 5;
                    const barX = this.x;
                    const barY = this.y - 10;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = `rgb(255, ${255 * (1 - chargeRatio)}, 0)`;
                    ctx.fillRect(barX, barY, barWidth * chargeRatio, barHeight);
                }

                // キャラクター画像
                if (playerImage && playerImage.complete && playerImage.naturalWidth > 0) {
                     // ... (画像描画は変更なし) ...
                    let drawX = this.x;
                    if (this.direction === 'left') {
                        ctx.scale(-1, 1);
                        drawX = -(this.x + this.width);
                    }
                    ctx.drawImage(playerImage, drawX, this.y, this.width, this.height);
                } else {
                    // フォールバック描画 (色と目)
                     // ... (フォールバック描画は変更なし) ...
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.fillStyle = '#FFFFFF';
                    const eyeWidth = 5, eyeHeight = 5, eyeY = this.y + 5;
                    let eyeX = (this.direction === 'right') ? this.x + this.width - eyeWidth - 3 : this.x + 3;
                    ctx.fillRect(eyeX, eyeY, eyeWidth, eyeHeight);
                }

                ctx.restore(); // フィルターや反転をリセット
            }

            // ジャンプ処理 (角度調整バージョン、変更なし)
            jump() {
                // ... (変更なし) ...
                if (this.onGround) {
                    const chargeRatio = Math.min(jumpCharge, MAX_JUMP_CHARGE) / MAX_JUMP_CHARGE;
                    const forceY = JUMP_FORCE_MIN + (JUMP_FORCE_MAX - JUMP_FORCE_MIN) * chargeRatio;
                    const forceX = JUMP_HORIZONTAL_SPEED_MIN + (JUMP_HORIZONTAL_SPEED_MAX - JUMP_HORIZONTAL_SPEED_MIN) * chargeRatio;
                    this.vy = -forceY;
                    this.onGround = false;
                    this.vx = (this.direction === 'left') ? -forceX : forceX;
                }
                isCharging = false;
                jumpCharge = 0;
                keys.Space = false;
            }
        }

        // 足場クラス (変更なし)
        class Platform {
             // ... (変更なし) ...
            constructor(x, y, width, height = 15) {
                this.x = x; this.y = y; this.width = width; this.height = height; this.color = '#654321';
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#8B5A2B'; ctx.fillRect(this.x, this.y, this.width, 3);
            }
        }

        // --- メッセージ表示 (変更なし) ---
        function showFallMessage() {
            // ... (変更なし) ...
            messageText.textContent = "下に落ちてしまった！";
            messageBox.classList.remove('hidden');
        }

        function updatePlayCountDisplay() {
             // ... (変更なし) ...
            if (playCountDisplay) playCountDisplay.textContent = playCount;
        }

        messageOk.addEventListener('click', () => {
             // ... (変更なし) ...
            messageBox.classList.add('hidden');
            playCount++;
            updatePlayCountDisplay();
            resetGame();
        });

        // --- BGM制御 (変更なし) ---
        async function playBgm() {
             // ... (変更なし) ...
            if (audioStarted) return;
            bgm.muted = false;
            try {
                await bgm.play();
                audioStarted = true;
                muteBtn.textContent = "BGM OFF";
                console.log("BGM started.");
            } catch (err) {
                console.warn("BGM autoplay failed.", err);
                muteBtn.textContent = "BGM ON";
            }
        }

        muteBtn.addEventListener('click', () => {
             // ... (変更なし) ...
            if (bgm.paused) playBgm();
            else { bgm.muted = !bgm.muted; muteBtn.textContent = bgm.muted ? "BGM ON" : "BGM OFF"; }
        });

        // --- ゲームの初期化・リセット (ステージ定義は変更なし) ---
        function createWorld() {
            // ... (ステージ定義は変更なし) ...
            platforms = [];
            let currentY = worldHeight;
            // --- ゾーン1 ---
            platforms.push(new Platform(50, currentY - 50, GAME_WIDTH - 100, 50)); // 0.
            platforms.push(new Platform(280, currentY - 150, 100, 15)); // 1.
            platforms.push(new Platform(150, currentY - 230, 100, 15)); // 2.
            platforms.push(new Platform(20, currentY - 330, 100, 15));  // 3.
            platforms.push(new Platform(250, currentY - 480, 130, 15)); // 4.
            platforms.push(new Platform(150, currentY - 600, 100, 15)); // 5.
            platforms.push(new Platform(20, currentY - 750, 80, 15));  // 6.
            platforms.push(new Platform(160, currentY - 900, 80, 15));  // 7.
            platforms.push(new Platform(300, currentY - 1050, 80, 15)); // 8.
            platforms.push(new Platform(150, currentY - 1250, 60, 15)); // 9.
            platforms.push(new Platform(20, currentY - 1450, 60, 15));  // 10.
            platforms.push(new Platform(200, currentY - 1650, 60, 15)); // 11.
            platforms.push(new Platform(300, currentY - 1670, 80, 15)); // 11b.
            platforms.push(new Platform(200, currentY - 1850, 100, 15)); // 12.
            platforms.push(new Platform(100, currentY - 1920, 80, 15)); // 12b.
            platforms.push(new Platform(200, currentY - 2000, GAME_WIDTH - 200, 50)); // 13a.
            platforms.push(new Platform(0, currentY - 2000, 150, 50)); // 13b.
            // --- ゾーン2 ---
            let y_zone2 = currentY - 2000;
            platforms.push(new Platform(130, y_zone2 - 150, 40, 15)); // 14.
            platforms.push(new Platform(300, y_zone2 - 300, 40, 15)); // 15.
            platforms.push(new Platform(100, y_zone2 - 480, 100, 15)); // 16. (①)
            platforms.push(new Platform(0, y_zone2 - 650, 150, 80));   // 17a.
            platforms.push(new Platform(200, y_zone2 - 650, 200, 80)); // 17b.
            platforms.push(new Platform(130, y_zone2 - 750, 70, 15));  // 18. (②)
            platforms.push(new Platform(50, y_zone2 - 950, 40, 15));   // 19.
            platforms.push(new Platform(250, y_zone2 - 1150, 40, 15)); // 20.
            platforms.push(new Platform(0, y_zone2 - 1350, 300, 80));   // 21a.
            platforms.push(new Platform(350, y_zone2 - 1350, 50, 80));  // 21b.
            platforms.push(new Platform(310, y_zone2 - 1450, 40, 15)); // 22.
            platforms.push(new Platform(150, y_zone2 - 1650, 40, 15)); // 23.
            platforms.push(new Platform(300, y_zone2 - 1850, 40, 15)); // 24.
            platforms.push(new Platform(250, y_zone2 - 2000, GAME_WIDTH - 250, 50)); // 24a.
            platforms.push(new Platform(0, y_zone2 - 2000, 200, 50)); // 24b.
            // --- ゾーン3 ---
            let y_zone3 = y_zone2 - 2000;
            platforms.push(new Platform(180, y_zone3 - 180, 60, 15)); // 25.
            platforms.push(new Platform(50, y_zone3 - 360, 48, 15));  // 26.
            platforms.push(new Platform(250, y_zone3 - 540, 36, 15)); // 27.
            platforms.push(new Platform(100, y_zone3 - 720, 60, 15)); // 28.
            platforms.push(new Platform(300, y_zone3 - 900, 36, 15)); // 29.
            platforms.push(new Platform(150, y_zone3 - 1100, 48, 15));// 30.
            platforms.push(new Platform(20, y_zone3 - 1300, 60, 15)); // 31.
            platforms.push(new Platform(200, y_zone3 - 1500, 36, 15));// 32.
            platforms.push(new Platform(50, y_zone3 - 1700, 48, 15)); // 33.
            platforms.push(new Platform(50, y_zone3 - 1900, 60, 15));// 34.
            platforms.push(new Platform(100, y_zone3 - 2000, GAME_WIDTH - 100, 50)); // 35a.
            platforms.push(new Platform(0, y_zone3 - 2000, 50, 50)); // 35b.
            platforms.push(new Platform(0, y_zone3 - 2100, 50, 15)); // Goal Top
        }

        function resetGame() {
            // ... (変更なし) ...
            const startPlatform = platforms[0];
            player = new Player(GAME_WIDTH / 2, startPlatform.y - 50);
            const startHeightInMeters = Math.max(0, Math.floor((worldHeight - player.y) / pixelsPerMeter));
            if (currentHeightDisplay) currentHeightDisplay.textContent = startHeightInMeters;
            cameraY = worldHeight - GAME_HEIGHT;
            if (maxHeightReached === 0 || player.y < maxHeightReached) {
                 maxHeightReached = player.y;
            }
            isCharging = false;
            jumpCharge = 0;
            keys.ArrowLeft = false; keys.ArrowRight = false; keys.Space = false;
        }

        function init() {
            // ... (変更なし) ...
            resizeCanvas();
            playerImage = new Image();
            playerImage.onload = () => { if (!gameStarted) startGame(); };
            playerImage.onerror = () => { playerImage = null; if (!gameStarted) startGame(); };
            playerImage.src = '/jumpingmidori/1000006120.jpg'; // 公開用パス
            setTimeout(() => { if (!gameStarted) startGame(); }, 5000);
        }

        function startGame() {
             // ... (変更なし) ...
            if (gameStarted) return;
            gameStarted = true;
            createWorld();
            playCount = 1;
            updatePlayCountDisplay();
            resetGame();
            playBgm();
            gameLoop();
        }

        // --- キャンバスのリサイズ処理 (変更なし) ---
        function resizeCanvas() {
             // ... (変更なし) ...
            const innerWidth = window.innerWidth;
            const innerHeight = window.innerHeight;
            const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;
            let newCanvasWidth, newCanvasHeight;
            if (innerWidth / innerHeight > gameAspectRatio) {
                newCanvasHeight = innerHeight;
                newCanvasWidth = newCanvasHeight * gameAspectRatio;
            } else {
                newCanvasWidth = innerWidth;
                newCanvasHeight = newCanvasWidth / gameAspectRatio;
            }
            canvas.style.width = `${newCanvasWidth}px`;
            canvas.style.height = `${newCanvasHeight}px`;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = GAME_WIDTH * dpr;
            canvas.height = GAME_HEIGHT * dpr;
            ctx.scale(dpr, dpr);
            const canvasRect = canvas.getBoundingClientRect();
            if(infoDisplay){ // Ensure infoDisplay is not null
                 infoDisplay.style.left = `${canvasRect.left + 10}px`;
                 infoDisplay.style.top = `${canvasRect.top + 10}px`;
             }
        }

        // --- ゲームループ (変更なし) ---
        function update() {
             // ... (変更なし, カメラ追従ロジックも含む) ...
            if (keys.Space && player && player.onGround && !isCharging) { isCharging = true; jumpCharge = 0; }
            if (isCharging && player && player.onGround && jumpCharge < MAX_JUMP_CHARGE) jumpCharge++;
            if (!player) return;
            player.update();

            // カメラ追従
            const cameraTargetYUp = player.y - GAME_HEIGHT / 3;
            if (cameraTargetYUp < cameraY) cameraY = cameraTargetYUp;
            // 神モード時の下降追従
            if (godMode) {
                const cameraTargetYDown = player.y - (GAME_HEIGHT * 0.75);
                if (cameraTargetYDown > cameraY) cameraY = cameraTargetYDown;
            }
            // カメラ範囲制限
            const topLimit = platforms.length > 0 ? platforms[platforms.length-1].y - 100 : 0; // 配列空チェック追加
            cameraY = Math.max(topLimit, Math.min(worldHeight - GAME_HEIGHT, cameraY));
        }

        function draw() {
            // ... (変更なし) ...
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(1/dpr, 1/dpr);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(canvas.width / GAME_WIDTH, canvas.height / GAME_HEIGHT);
            ctx.translate(0, -cameraY);

            // 背景色
            let currentHeightMeters = player ? Math.max(0, Math.floor((worldHeight - player.y) / pixelsPerMeter)) : 0;
            let bgColor = '#87CEEB'; // 空
            if (currentHeightMeters >= 600) bgColor = '#191970'; // 宇宙
            else if (currentHeightMeters >= 400) bgColor = '#483D8B'; // 夜
            else if (currentHeightMeters >= 200) bgColor = '#FFA07A'; // 夕焼け
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, cameraY, GAME_WIDTH, GAME_HEIGHT);

            // オブジェクト描画
            platforms.forEach(p => p.draw(ctx));
            if(player) player.draw(ctx);

            ctx.restore(); // カメラ変換戻す
            ctx.restore(); // スケール戻す
        }

        function gameLoop() {
            // ... (変更なし) ...
            if (messageBox.classList.contains('hidden')) update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- イベントリスナー (キーボード、タッチは変更なし) ---
        function handleFirstInteraction() { if (!audioStarted) playBgm(); }

        // キーボード
        function handleKeyDown(e) { /* ... (変更なし) ... */ handleFirstInteraction(); if (e.key === 'ArrowLeft') keys.ArrowLeft = true; else if (e.key === 'ArrowRight') keys.ArrowRight = true; if (e.key === ' ') { e.preventDefault(); keys.Space = true; if (player && player.onGround && !isCharging) { if (keys.ArrowLeft && !keys.ArrowRight) player.direction = 'left'; else if (keys.ArrowRight && !keys.ArrowLeft) player.direction = 'right'; } } }
        function handleKeyUp(e) { /* ... (変更なし) ... */ if (e.key === 'ArrowLeft') keys.ArrowLeft = false; else if (e.key === 'ArrowRight') keys.ArrowRight = false; if (e.key === ' ') { if (isCharging && player) player.jump(); } }

        // タッチ
        function handleTouchStart(e) { /* ... (変更なし) ... */ handleFirstInteraction(); e.preventDefault(); const targetId = e.target.id; if (targetId === 'btn-left') keys.ArrowLeft = true; else if (targetId === 'btn-right') keys.ArrowRight = true; else if (targetId === 'btn-jump') { keys.Space = true; if (player && player.onGround && !isCharging) { if (keys.ArrowLeft && !keys.ArrowRight) player.direction = 'left'; else if (keys.ArrowRight && !keys.ArrowLeft) player.direction = 'right'; } } }
        function handleTouchEnd(e) { /* ... (変更なし) ... */ e.preventDefault(); for (let touch of e.changedTouches) { const targetId = touch.target.id; if (targetId === 'btn-left') keys.ArrowLeft = false; else if (targetId === 'btn-right') keys.ArrowRight = false; else if (targetId === 'btn-jump') { if (isCharging && player) player.jump(); } } if (e.touches.length === 0) { keys.ArrowLeft = false; keys.ArrowRight = false; } }

        // ★ キャンバスへのタップイベントリスナー (神モード用) - 座標変換を修正
        canvas.addEventListener('click', (event) => {
            if (!player || !gameStarted) return;

            const rect = canvas.getBoundingClientRect();
            // ★★★ 座標変換ロジックを修正 ★★★
            // event.clientX/Y はビューポートに対する座標
            // これを canvas 要素の左上を原点とする座標に変換
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            // canvas 要素上の座標 (CSSピクセル) をゲーム内座標に変換
            // rect.width/height は CSS ピクセルでの表示サイズ
            const gameClickX = (canvasX / rect.width) * GAME_WIDTH;
            // カメラのスクロール分を加味して Y 座標を計算
            const gameClickY = ((canvasY / rect.height) * GAME_HEIGHT) + cameraY;


            // プレイヤーの現在の描画範囲 (向きは考慮不要)
            const playerRect = {
                x: player.x,
                y: player.y,
                width: player.width,
                height: player.height
            };

            // タップ座標がプレイヤー範囲内かチェック
            if (gameClickX >= playerRect.x && gameClickX <= playerRect.x + playerRect.width &&
                gameClickY >= playerRect.y && gameClickY <= playerRect.y + playerRect.height) {

                 // ★ タップフィードバック表示
                 handlePlayerTapFeedback();

                const now = Date.now();
                if (now - lastPlayerTapTime < tapTimeout) {
                    playerTapCount++;
                } else {
                    playerTapCount = 1;
                }
                lastPlayerTapTime = now;

                if (playerTapCount >= 5) {
                    godMode = !godMode;
                    console.log(`God Mode ${godMode ? 'ON' : 'OFF'}`); // コンソールに表示
                    playerTapCount = 0; // リセット
                }
            } else {
                 playerTapCount = 0; // プレイヤー以外をタップしたらリセット
            }
        });

        // ★ タップフィードバック処理
        function handlePlayerTapFeedback() {
            if (tapFeedbackTimer) clearTimeout(tapFeedbackTimer); // 前のタイマーがあればクリア
            showTapFeedback = true;
            tapFeedbackTimer = setTimeout(() => {
                showTapFeedback = false;
                tapFeedbackTimer = null;
            }, 100); // 100ms後にフィードバックを消す
        }


        // ウィンドウリサイズ
        window.addEventListener('resize', resizeCanvas);
        // キーボード入力
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        // タッチ入力
        const controls = document.getElementById('touch-controls');
        controls.addEventListener('touchstart', handleTouchStart, { passive: false });
        controls.addEventListener('touchend', handleTouchEnd, { passive: false });
        controls.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // 神モードボタンの処理は削除済み

        // ゲーム開始
        window.addEventListener('load', init);

    </script>
</body>
</html>

