<!DOCTYPE html>
<html lang="ja">
<head>
    <!-- ... (head content as before) ... -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ジャンプキング風ゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ... (styles as before) ... */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 画面スクロールを禁止 */
            background-color: #333;
            font-family: 'Inter', sans-serif;
        }
        #game-canvas {
            display: block;
            /* 背景色はJSで制御するため削除 */
            width: 100%;
            height: 100%;
            object-fit: contain; /* アスペクト比を維持 */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 10;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .touch-btn {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%; /* 円形ボタン */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-btn:active {
            background-color: rgba(255, 255, 255, 0.7);
        }
        
        /* ★ BGMボタン用のスタイル */
        #mute-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid white;
            cursor: pointer;
            margin-top: 8px;
            font-size: 14px;
        }
        #mute-btn:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="message-box" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg shadow-lg text-center hidden">
            <p id="message-text" class="text-xl font-bold mb-4"></p>
            <button id="message-ok" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                OK
            </button>
        </div>
        <!-- チュートリアル/スコア表示 (テキストを修正) -->
        <div id="info-display" class="absolute top-4 left-4 text-white text-lg font-bold p-2 bg-black bg-opacity-30 rounded-lg">
            <p>Space / JUMP長押し + 左右キーで方向決定！</p>
            <p>最高到達点: <span id="max-height-display">0</span>m</p>
            <!-- ★ BGMボタンを追加 -->
            <button id="mute-btn">BGM ON/OFF</button>
        </div>
    </div>

    <div id="touch-controls">
        <div class="flex space-x-4">
            <button id="btn-left" class="touch-btn">◀</button>
            <button id="btn-right" class="touch-btn">▶</button>
        </div>
        <button id="btn-jump" class="touch-btn w-20 h-20">JUMP</button>
    </div>

    <!-- ★ BGM用Audioタグを追加 -->
    <!-- ★ GitHub Pages公開用にパスを修正 -->
    <audio id="bgm-audio" loop src="/jumpingmidori/闇のささやき.mp3"></audio>

    <script type="module">
        // --- グローバル変数・定数 ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        const infoDisplay = document.getElementById('info-display');
        const maxHeightDisplay = document.getElementById('max-height-display');

        // ★ BGM関連
        const bgm = document.getElementById('bgm-audio');
        const muteBtn = document.getElementById('mute-btn');
        let audioStarted = false; // ユーザー操作による再生開始フラグ

        // ゲーム内単位での仮想解像度
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 600;

        let player;
        let platforms = [];
        let keys = {
            ArrowLeft: false,
            ArrowRight: false,
            Space: false
        };
        
        // ★ 画像読み込み用の変数
        let playerImage;
        let gameStarted = false; // 二重起動防止

        // 物理定数
        const GRAVITY = 0.3;
        const FRICTION = 0.85; // 地上での摩擦 (ジャンプ後は使われない)
        const AIR_FRICTION = 0.99; // 空中での水平速度の減衰
        
        const JUMP_HORIZONTAL_SPEED_MIN = 0.5; // ★微調整ジャンプ時の水平速度
        const JUMP_HORIZONTAL_SPEED_NORMAL = 5.0; // ★通常ジャンプ時の水平速度 (固定値)
        const JUMP_HORIZONTAL_SPEED_MAX = 6; // (使わない)
        
        const MAX_JUMP_CHARGE = 100; // ジャンプ溜めの最大値
        const JUMP_FORCE_MIN = 1; // 最小ジャンプ力 (垂直)
        const JUMP_FORCE_MAX = 15; // 最大ジャンプ力 (垂直)

        let isCharging = false;
        let jumpCharge = 0;
        let cameraY = 0; // カメラのY座標 (どれだけ上にスクロールしたか)
        let worldHeight = 5000; // ステージの総高さ
        let maxHeightReached = 0; // 最高到達点 (Y座標なので小さいほど高い)
        let pixelsPerMeter = 10; // 1メートルあたりのピクセル数（スコア表示用）

        // メッセージボックス
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOk = document.getElementById('message-ok');

        // --- クラス定義 ---

        // プレイヤー
        class Player {
            constructor(x, y) {
                this.width = 20;
                this.height = 30;
                this.x = x - this.width / 2;
                this.y = y - this.height;
                this.vx = 0; 
                this.vy = 0; 
                this.onGround = false;
                this.color = '#FF5733'; // フォールバック時の色
                this.direction = 'right'; // ★向きを追加 (最初は右)
            }

            // プレイヤーの更新
            update() {
                // 1. 入力に基づく水平移動・方向転換
                // ★地上にいて、ジャンプ溜め中でない場合のみ、方向転換を許可
                if (this.onGround && !isCharging) {
                    if (keys.ArrowLeft) {
                        this.direction = 'left';
                    } else if (keys.ArrowRight) {
                        this.direction = 'right';
                    }
                    this.vx = 0; // 地上では常に水平速度0
                }
                // ★空中での左右操作は不可
                else if (this.onGround) {
                     this.vx = 0; // ジャンプ溜め中も水平速度0
                }

                
                // 2. 物理演算
                this.vy += GRAVITY; // 重力
                
                // 摩擦
                if (this.onGround) { 
                    // 地面上ではvxは0
                    this.vx *= FRICTION;
                } else if (!this.onGround) { // 空中
                    // ★空中にいる間は、キー入力に関わらず水平速度は減衰していく
                    this.vx *= AIR_FRICTION;
                }
                
                // 速度が小さすぎたら0にする
                if (Math.abs(this.vx) < 0.1) this.vx = 0;
                if (Math.abs(this.vy) < 0.1 && this.onGround && !isCharging) this.vy = 0; // ジャンプ溜め中は微小なvyでも0にしない

                // 古い位置を保存
                const prevX = this.x;
                const prevY = this.y;

                // 3. 位置の更新
                this.x += this.vx;
                this.y += this.vy;
                
                this.onGround = false; // 毎フレームリセット

                // 4. 当たり判定 (壁)
                // ★壁に当たったら水平速度を反転させる (ジャンプキング風)
                if (this.x < 0) {
                    this.x = 0;
                    this.vx *= -0.5; // 少し跳ね返る
                }
                if (this.x + this.width > GAME_WIDTH) {
                    this.x = GAME_WIDTH - this.width;
                    this.vx *= -0.5; // 少し跳ね返る
                }
                
                // 5. 当たり判定 (足場)
                platforms.forEach(platform => {
                    // 足場とプレイヤーの現在位置での重なりをチェック
                    const isCollidingX = this.x + this.width > platform.x && this.x < platform.x + platform.width;
                    const isCollidingY = this.y + this.height > platform.y && this.y < platform.y + platform.height;
                    
                    // 前フレームでの水平方向の重なり
                    const wasCollidingX = prevX + this.width > platform.x && prevX < platform.x + platform.width;

                    if (isCollidingX && isCollidingY) {
                        // プレイヤーの底辺が足場の上辺と重なる場合 (上から乗る)
                        if (prevY + this.height <= platform.y && this.y + this.height > platform.y && this.vy >= 0) {
                            this.y = platform.y - this.height; // 足場の上 乗せる
                            this.vy = 0;
                            this.onGround = true;
                        }
                        // プレイヤーの頭が足場の底辺と重なる場合 (下から衝突)
                        else if (prevY >= platform.y + platform.height && this.y < platform.y + platform.height && this.vy < 0) {
                            this.y = platform.y + platform.height; // 足場の下端で止める
                            this.vy = 0; // 上向きの速度を0にする
                        }
                    }
                    
                    // ★横からの衝突判定 (空中にいるとき)
                    if (!this.onGround && !isCollidingY && !wasCollidingX) {
                         // 前フレームでは横が重なっておらず、今フレームで重なっている
                         // かつ、Y方向は（前フレームでも今フレームでも）重なっている
                         const wasCollidingY = prevY + this.height > platform.y && prevY < platform.y + platform.height;
                         if (isCollidingX && wasCollidingY) {
                            // 左右どちらから衝突したか
                             if (this.vx > 0 && prevX + this.width <= platform.x) { // 右に移動中
                                 this.x = platform.x - this.width;
                                 this.vx *= -0.5; // 反転
                             } else if (this.vx < 0 && prevX >= platform.x + platform.width) { // 左に移動中
                                 this.x = platform.x + platform.width;
                                 this.vx *= -0.5; // 反転
                             }
                         }
                    }
                });

                // 6. 落下判定 (画面下 + カメラ位置より下に落ちた)
                if (this.y > cameraY + GAME_HEIGHT + 100) {
                    showFallMessage();
                }

                // 7. 最高到達点の更新
                if (this.y < maxHeightReached) {
                    maxHeightReached = this.y;
                    // スコア表示を更新 (スタート地点(worldHeight)からの差分)
                    const heightInMeters = Math.floor((worldHeight - maxHeightReached) / pixelsPerMeter);
                    maxHeightDisplay.textContent = heightInMeters;
                }

            }

            // プレイヤーの描画
            draw(ctx) {
                ctx.save(); // 描画状態を保存

                // ジャンプパワーゲージの描画 (キャラクターより手前)
                if (isCharging) {
                    const chargeRatio = jumpCharge / MAX_JUMP_CHARGE;
                    const barWidth = this.width;
                    const barHeight = 5;
                    const barX = this.x;
                    const barY = this.y - 10; // 頭上

                    // ゲージの枠
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // ゲージ本体 (赤くする)
                    ctx.fillStyle = `rgb(255, ${255 * (1 - chargeRatio)}, 0)`;
                    ctx.fillRect(barX, barY, barWidth * chargeRatio, barHeight);
                }

                // ★ キャラクター画像の描画
                // (playerImage が存在し、読み込み完了している場合)
                if (playerImage && playerImage.complete && playerImage.naturalWidth > 0) {
                    let drawX = this.x;

                    if (this.direction === 'left') {
                        // 左向きの場合、キャンバスを反転
                        ctx.scale(-1, 1);
                        // 反転したため、描画X座標を調整 (プレイヤーの中心で反転させるためwidth分ずらす)
                        drawX = -(this.x + this.width); 
                    }

                    // (drawX, this.y) の位置に (width, height) のサイズで画像を描画
                    ctx.drawImage(playerImage, drawX, this.y, this.width, this.height);

                } else {
                    // 画像読み込み失敗時のフォールバック (赤い四角)
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // ★向きを示す「目」を描画 (フォールバック時)
                    ctx.fillStyle = '#FFFFFF'; 
                    const eyeWidth = 5;
                    const eyeHeight = 5;
                    const eyeY = this.y + 5;
                    let eyeX;

                    if (this.direction === 'right') {
                        eyeX = this.x + this.width - eyeWidth - 3; // 右端
                    } else {
                        eyeX = this.x + 3; // 左端
                    }
                    ctx.fillRect(eyeX, eyeY, eyeWidth, eyeHeight);
                }
                
                ctx.restore(); // 描画状態を元に戻す (反転などをリセット)
            }


            // ★★★ ジャンプ処理のロジックを修正 ★★★
            jump() {
                if (this.onGround) {
                    // 溜め時間に応じてジャンプ力を計算
                    const chargeRatio = Math.min(jumpCharge, MAX_JUMP_CHARGE) / MAX_JUMP_CHARGE;
                    
                    // ★垂直方向のジャンプ力 (溜めに比例)
                    const forceY = JUMP_FORCE_MIN + (JUMP_FORCE_MAX - JUMP_FORCE_MIN) * chargeRatio;
                    
                    let forceX;
                    // ★水平方向のジャンプ力 (溜め10%未満は微調整、それ以上は固定値)
                    if (chargeRatio < 0.1) {
                        // チョン押し (微調整)
                        forceX = JUMP_HORIZONTAL_SPEED_MIN;
                    } else {
                        // 通常ジャンプ (溜め具合に関わらず水平速度は一定)
                        forceX = JUMP_HORIZONTAL_SPEED_NORMAL;
                    }

                    this.vy = -forceY;
                    this.onGround = false;
                    
                    // ★ 水平方向の速度を、キー入力ではなく「向き」に基づいて決定
                    if (this.direction === 'left') {
                        this.vx = -forceX;
                    } else { // 'right'
                        this.vx = forceX;
                    }
                }
                // 溜め状態をリセット
                isCharging = false;
                jumpCharge = 0;
                keys.Space = false; // ジャンプ実行後、Spaceキーの状態もリセット
            }
        }

        // 足場
        class Platform {
            constructor(x, y, width, height = 15) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#654321'; // 茶色
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 少し立体的に見せるための明るい上辺
                ctx.fillStyle = '#8B5A2B';
                ctx.fillRect(this.x, this.y, this.width, 3);
            }
        }

        // --- メッセージ表示 ---
        function showFallMessage() {
            // "下に落ちてしまった！"
            messageText.textContent = "下に落ちてしまった！";
            messageBox.classList.remove('hidden');
        }

        messageOk.addEventListener('click', () => {
            messageBox.classList.add('hidden');
            resetGame(); // OKを押したらリセット
        });


        // --- BGM制御 ---
        // ★ BGM再生を試みる関数
        async function playBgm() {
            if (audioStarted) return; // 既に開始しようとした
            
            // mutedプロパティで再生開始
            bgm.muted = false; // ミュート解除
            try {
                await bgm.play();
                audioStarted = true; // 再生成功
                muteBtn.textContent = "BGM OFF";
                console.log("BGM started.");
            } catch (err) {
                console.warn("BGM autoplay failed. Waiting for user interaction.", err);
                // ユーザー操作があるまで再生は保留される
                muteBtn.textContent = "BGM ON"; // 再生失敗時はON表示
            }
        }

        // ★ ミュートボタンのクリックイベント
        muteBtn.addEventListener('click', () => {
            if (bgm.paused) {
                // もし停止中なら再生（初回再生用）
                playBgm();
            } else {
                // 再生中ならミュート切り替え
                bgm.muted = !bgm.muted;
                muteBtn.textContent = bgm.muted ? "BGM ON" : "BGM OFF";
            }
        });


        // --- ゲームの初期化・リセット ---
        
        // ★ 固定ステージを定義 (ゾーン1簡略化、ゾーン2変更)
        function createWorld() {
            platforms = [];
            let currentY = worldHeight; // Y座標の基点 (5000)

            // --- ゾーン1 (0m - 200m) ---
            platforms.push(new Platform(50, currentY - 50, GAME_WIDTH - 100, 50)); // 0. スタート
            platforms.push(new Platform(280, currentY - 150, 100, 15)); // 1. 
            platforms.push(new Platform(150, currentY - 230, 100, 15)); // 2. 
            platforms.push(new Platform(20, currentY - 330, 100, 15));  // 3.
            platforms.push(new Platform(250, currentY - 480, 130, 15)); // 4.
            platforms.push(new Platform(150, currentY - 600, 100, 15)); // 5. 
            platforms.push(new Platform(20, currentY - 750, 80, 15));  // 6. 
            platforms.push(new Platform(160, currentY - 900, 80, 15));  // 7. 
            platforms.push(new Platform(300, currentY - 1050, 80, 15)); // 8. 
            platforms.push(new Platform(150, currentY - 1250, 60, 15)); // 9. 
            platforms.push(new Platform(20, currentY - 1450, 60, 15));  // 10.
            platforms.push(new Platform(200, currentY - 1650, 60, 15)); // 11. 
            
            // ★ 修正: 195m地点を簡単な階段に変更
            platforms.push(new Platform(200, currentY - 1850, 100, 15)); // 12. (Y:3150)
            platforms.push(new Platform(100, currentY - 1920, 80, 15)); // 12b. ★新しい階段 (Y:3080)
            
            // ゾーン1 -> 2 への中間地点 (約200m地点, Y: 3000)
            // (登るための隙間は(X:150-200)に確保)
            platforms.push(new Platform(200, currentY - 2000, GAME_WIDTH - 200, 50)); // 13a. 右側
            platforms.push(new Platform(0, currentY - 2000, 150, 50)); // 13b. 左側

            // --- ゾーン2 (200m - 400m) ---
            // ★ 難易度: 角度と高さを意識するステージ (狭い足場と隙間)
            let y_zone2 = currentY - 2000; // Y: 3000 からスタート
            
            platforms.push(new Platform(130, y_zone2 - 150, 40, 15)); // 14. 狭い足場
            platforms.push(new Platform(300, y_zone2 - 300, 40, 15)); // 15. 狭い足場
            platforms.push(new Platform(100, y_zone2 - 480, 40, 15)); // 16. 狭い足場

            // 壁1 (隙間: X 150-200)
            platforms.push(new Platform(0, y_zone2 - 650, 150, 80));   // 17a. 左壁
            platforms.push(new Platform(200, y_zone2 - 650, 200, 80)); // 17b. 右壁
            
            platforms.push(new Platform(160, y_zone2 - 750, 40, 15));  // 18. 隙間の後の足場

            platforms.push(new Platform(50, y_zone2 - 950, 40, 15));   // 19. 狭い足場
            platforms.push(new Platform(250, y_zone2 - 1150, 40, 15)); // 20. 狭い足場
            
            // 壁2 (隙間: X 300-350)
            platforms.push(new Platform(0, y_zone2 - 1350, 300, 80));   // 21a. 左壁
            platforms.push(new Platform(350, y_zone2 - 1350, 50, 80));  // 21b. 右壁

            platforms.push(new Platform(310, y_zone2 - 1450, 40, 15)); // 22. 隙間の後の足場
            platforms.push(new Platform(150, y_zone2 - 1650, 40, 15)); // 23. 狭い足場
            platforms.push(new Platform(300, y_zone2 - 1850, 40, 15)); // 24. 最後の狭い足場

            // ゾーン2 -> 3 への中間地点 (約400m地点, Y: 1000)
            platforms.push(new Platform(250, y_zone2 - 2000, GAME_WIDTH - 250, 50)); // 24a. 右側
            platforms.push(new Platform(0, y_zone2 - 2000, 200, 50)); // 24b. 左側
            
            // --- ゾーン3 (400m - 600m) ---
            // (元のデザインのまま)
            let y_zone3 = y_zone2 - 2000; // Y: 1000 からスタート
            
            platforms.push(new Platform(180, y_zone3 - 180, 60, 15)); // 25. 
            platforms.push(new Platform(50, y_zone3 - 360, 48, 15));  // 26. 
            platforms.push(new Platform(250, y_zone3 - 540, 36, 15)); // 27. 
            platforms.push(new Platform(100, y_zone3 - 720, 60, 15)); // 28. 
            platforms.push(new Platform(300, y_zone3 - 900, 36, 15)); // 29. 
            platforms.push(new Platform(150, y_zone3 - 1100, 48, 15));// 30. 
            platforms.push(new Platform(20, y_zone3 - 1300, 60, 15)); // 31. 
            platforms.push(new Platform(200, y_zone3 - 1500, 36, 15));// 32. 
            platforms.push(new Platform(50, y_zone3 - 1700, 48, 15)); // 33. 
            platforms.push(new Platform(50, y_zone3 - 1900, 60, 15));// 34. 
            
            // ゾーン3 ゴール (約600m地点, Y: -1000)
            platforms.push(new Platform(100, y_zone3 - 2000, GAME_WIDTH - 100, 50)); // 35a. 右側
            platforms.push(new Platform(0, y_zone3 - 2000, 50, 50)); // 35b. 左側
            
            // ゴール後の最上部 (Y: -1100)
            platforms.push(new Platform(0, y_zone3 - 2100, 50, 15)); 
        }


        function resetGame() {
            // ★ ステージは再生成しない
            // createWorld();
            
            // スタート地点 (Y座標はworldHeight)
            const startPlatform = platforms[0]; // 最初の足場
            player = new Player(GAME_WIDTH / 2, startPlatform.y - 50);
            
            cameraY = worldHeight - GAME_HEIGHT; // カメラをスタート地点に合わせる
            
            // maxHeightReachedはリセットするが、表示はグローバルな最大値を保持したい
            if (maxHeightReached === 0 || player.y < maxHeightReached) {
                 maxHeightReached = player.y; // リセット後のプレイヤー位置
            }
            // maxHeightDisplay.textContent = '0'; // 0にリセットしない
            
            isCharging = false;
            jumpCharge = 0;
            // キー状態もリセット
            keys.ArrowLeft = false;
            keys.ArrowRight = false;
            keys.Space = false;
        }

        // ★ init関数を修正 (画像読み込み待機)
        function init() {
            resizeCanvas(); // 最初にキャンバスサイズを調整
            
            playerImage = new Image();
            
            // ★ 画像読み込み完了時の処理
            playerImage.onload = () => {
                console.log("Player image loaded.");
                if (!gameStarted) {
                    startGame();
                }
            };
            // ★ 画像読み込みエラー時の処理
            playerImage.onerror = () => {
                console.error("Failed to load player image. Using fallback rectangle.");
                playerImage = null; // 画像をnullにしてフォールバック描画を強制
                 if (!gameStarted) {
                    startGame();
                }
            };
            
            // ★ GitHub Pages公開用にパスを修正
            playerImage.src = '/jumpingmidori/1000006120.jpg'; 
            
            // タイムアウト処理 (画像読み込みに失敗してもゲームを開始する)
            setTimeout(() => {
                if (!gameStarted) {
                    console.warn("Image load timeout. Starting game.");
                    startGame();
                }
            }, 5000); // 5秒待機
        }
        
        // ★ ゲーム開始ロジックを分離
        function startGame() {
            if (gameStarted) return; // 既に開始されている場合は何もしない
            gameStarted = true;
            
            // ★ 初回のみステージを生成する
            createWorld(); 
            resetGame();
            
            // ★ BGM再生を試みる
            playBgm();
            
            gameLoop(); // ゲームループ開始
        }


        // --- キャンバスのリサイズ処理 ---
        function resizeCanvas() {
            // ウィンドウの内部サイズを取得
            const innerWidth = window.innerWidth;
            const innerHeight = window.innerHeight;

            // ゲームのアスペクト比 (幅 / 高さ)
            const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;
            
            let newCanvasWidth, newCanvasHeight;

            // ウィンドウの高さに基づいて幅を決めるか、幅に基づいて高さを決めるか
            if (innerWidth / innerHeight > gameAspectRatio) {
                // ウィンドウが横長すぎる場合 (高さを基準にする)
                newCanvasHeight = innerHeight;
                newCanvasWidth = newCanvasHeight * gameAspectRatio;
            } else {
                // ウィンドウが縦長すぎる場合 (幅を基準にする)
                newCanvasWidth = innerWidth;
                newCanvasHeight = newCanvasWidth / gameAspectRatio;
            }

            // キャンバスの表示サイズ（CSS）を設定
            canvas.style.width = `${newCanvasWidth}px`;
            canvas.style.height = `${newCanvasHeight}px`;

            // キャンバスの内部解像度（描画）を設定
            const dpr = window.devicePixelRatio || 1;
            canvas.width = GAME_WIDTH * dpr;
            canvas.height = GAME_HEIGHT * dpr;
            
            // スケーリングを設定
            ctx.scale(dpr, dpr);

            // info-displayの位置調整 (キャンバスの左上に合わせる)
            const canvasRect = canvas.getBoundingClientRect();
            infoDisplay.style.left = `${canvasRect.left + 10}px`;
            infoDisplay.style.top = `${canvasRect.top + 10}px`;
        }


        // --- ゲームループ ---
        function update() {
            // ジャンプ溜め
            // 地面にいる、かつSpaceキーが押されている、かつ現在溜め中でない場合
            if (keys.Space && player.onGround && !isCharging) {
                isCharging = true;
                jumpCharge = 0; // 新しいジャンプの溜めを開始
            }

            if (isCharging && player.onGround) {
                if (jumpCharge < MAX_JUMP_CHARGE) {
                    jumpCharge++;
                }
            }
            
            player.update();
            
            // カメラ追従 (プレイヤーが画面の上1/3より上に進んだら)
            const cameraTargetY = player.y - GAME_HEIGHT / 3;
            
            // ジャンプキング風: プレイヤーが一定ラインを超えたら即座に追従
            if (cameraTargetY < cameraY) {
                 cameraY = cameraTargetY;
            }
            
            // カメラがスタート地点より下に行かないように
            if (cameraY > worldHeight - GAME_HEIGHT) {
                cameraY = worldHeight - GAME_HEIGHT;
            }
            // カメラがワールドの上限を超えないように
            const topLimit = platforms[platforms.length-1].y - 100; // 最後の足場より少し上
            if (cameraY < topLimit) {
                 cameraY = topLimit;
            }
        }

        function draw() {
            ctx.save();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(1/dpr, 1/dpr); // スケーリングをリセット
            
            // 画面クリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 仮想解像度(GAME_WIDTH, GAME_HEIGHT)で描画するようにスケール
            ctx.save();
            ctx.scale(canvas.width / GAME_WIDTH, canvas.height / GAME_HEIGHT);


            // --- カメラ変換 ---
            ctx.translate(0, -cameraY);
            
            // ★ 背景色 (カメラ範囲のみ) を高度に応じて変更
            let currentHeightMeters = 0;
            if (player) {
                // 現在のプレイヤーのY座標から高さを計算
                currentHeightMeters = Math.max(0, Math.floor((worldHeight - player.y) / pixelsPerMeter));
            }

            let bgColor = '#87CEEB'; // 0-199m (空)
            if (currentHeightMeters >= 200 && currentHeightMeters < 400) {
                bgColor = '#FFA07A'; // 200-399m (夕焼け)
            } else if (currentHeightMeters >= 400 && currentHeightMeters < 600) {
                bgColor = '#483D8B'; // 400-599m (夜)
            } else if (currentHeightMeters >= 600) {
                bgColor = '#191970'; // 600m+ (宇宙)
            }
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, cameraY, GAME_WIDTH, GAME_HEIGHT);


            // --- オブジェクト描画 ---
            platforms.forEach(p => p.draw(ctx));
            
            // ★ player.draw が null でないことを確認 (初期化前対策)
            if(player) {
                player.draw(ctx);
            }
            
            ctx.restore(); // カメラ変換を戻す
            ctx.restore(); // スケールを戻す
        }

        function gameLoop() {
            if (messageBox.classList.contains('hidden')) { // メッセージ表示中は停止
                update();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- イベントリスナー ---
        
        // ★ 最初のユーザー操作でBGM再生を試みる
        function handleFirstInteraction() {
            if (!audioStarted) {
                playBgm();
            }
        }
        
        // キーボード操作
        function handleKeyDown(e) {
            handleFirstInteraction(); // ★ BGM再生トリガー
            
            if (e.key === 'ArrowLeft') {
                keys.ArrowLeft = true;
            } else if (e.key === 'ArrowRight') {
                keys.ArrowRight = true;
            }
            if (e.key === ' ') {
                e.preventDefault(); 
                keys.Space = true;
                
                // ★スペースを押した瞬間に、現在の左右キー入力で向きを更新する
                // (地上で溜め始めた瞬間の方向転換)
                if (player && player.onGround && !isCharging) {
                    if (keys.ArrowLeft && !keys.ArrowRight) {
                        player.direction = 'left';
                    } else if (keys.ArrowRight && !keys.ArrowLeft) {
                        player.direction = 'right';
                    }
                }
            }
        }

        function handleKeyUp(e) {
            if (e.key === 'ArrowLeft') {
                keys.ArrowLeft = false;
            } else if (e.key === 'ArrowRight') {
                keys.ArrowRight = false;
            }
            // スペースキーを離した（ジャンプ実行）
            if (e.key === ' ') {
                // keys.Space = false; // player.jump()内でリセット
                if (isCharging && player) {
                    player.jump();
                }
            }
        }

        // タッチ操作
        function handleTouchStart(e) {
            handleFirstInteraction(); // ★ BGM再生トリガー
            
            e.preventDefault(); 
            const targetId = e.target.id;
            
            if (targetId === 'btn-left') {
                keys.ArrowLeft = true;
            } else if (targetId === 'btn-right') {
                keys.ArrowRight = true;
            } else if (targetId === 'btn-jump') {
                keys.Space = true;
                
                // ★スペースを押した瞬間に、現在の左右キー入力で向きをS更新する
                if (player && player.onGround && !isCharging) {
                    if (keys.ArrowLeft && !keys.ArrowRight) {
                        player.direction = 'left';
                    } else if (keys.ArrowRight && !keys.ArrowLeft) {
                        player.direction = 'right';
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // 押されていたボタンを特定するために changedTouches を見る
            for (let touch of e.changedTouches) {
                // touch.target が押されていた要素
                const targetId = touch.target.id;

                if (targetId === 'btn-left') {
                    keys.ArrowLeft = false;
                } else if (targetId === 'btn-right') {
                    keys.ArrowRight = false;
                } else if (targetId === 'btn-jump') {
                    // keys.Space = false; // player.jump()内でリセット
                    if (isCharging && player) {
                        player.jump();
                    }
                }
            }
            
            // もしタッチがすべて離れたら、念のため左右キーの状態はリセット
            // Spaceキーはジャンプ処理でリセットされるのでここでは不要
             if (e.touches.length === 0) {
                keys.ArrowLeft = false;
                keys.ArrowRight = false;
            }
        }

        // ウィンドウリサイズ
        window.addEventListener('resize', resizeCanvas);
        
        // キーボード入力
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);

        // タッチ入力
        const controls = document.getElementById('touch-controls');
        controls.addEventListener('touchstart', handleTouchStart, { passive: false });
        controls.addEventListener('touchend', handleTouchEnd, { passive: false });
        controls.addEventListener('touchcancel', handleTouchEnd, { passive: false }); // 予期せぬキャンセル

        // ゲーム開始
        window.addEventListener('load', init);

    </script>
</body>
</html>

